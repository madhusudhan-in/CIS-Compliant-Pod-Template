apiVersion: v1
kind: Pod
metadata:
  name: secure-pod-template
  namespace: production
  labels:
    app: secure-app
    version: "1.0.0"
    environment: production
    team: security
    cost-center: "SEC-001"
    compliance: "CIS-LEVEL-2"
  annotations:
    security.kubernetes.io/psp: "restricted"
    prometheus.io/scrape: "true"
    prometheus.io/port: "8080"
    prometheus.io/path: "/metrics"
    sidecar.istio.io/inject: "false"
    checksum/config: "{{ .Values.configChecksum }}"
spec:
  # Pod-level security context
  securityContext:
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000
    seccompProfile:
      type: RuntimeDefault
    sysctls:
      - name: net.ipv4.ip_local_port_range
        value: "32768 65535"
      - name: net.ipv4.tcp_max_syn_backlog
        value: "4096"
    fsGroupChangePolicy: OnRootMismatch
    supplementalGroups: [2000, 3000]
    seLinuxOptions:
      level: "s0:c123,c456"
  
  # Priority class for resource scheduling
  priorityClassName: "high-priority"
  
  # Node affinity for security and performance
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: "kubernetes.io/os"
            operator: In
            values:
            - linux
          - key: "node-role.kubernetes.io/worker"
            operator: Exists
          - key: "security.kubernetes.io/secure-node"
            operator: In
            values:
            - "true"
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: app
              operator: In
              values:
              - secure-app
          topologyKey: kubernetes.io/hostname
  
  # Tolerations for dedicated nodes
  tolerations:
  - key: "dedicated"
    operator: "Equal"
    value: "security"
    effect: "NoSchedule"
  
  containers:
    - name: secure-container
      image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}@{{ .Values.image.digest }}"
      imagePullPolicy: Always
      imagePullSecrets:
        - name: "{{ .Values.imagePullSecrets.name }}"
      
      # Enhanced security context
      securityContext:
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
        runAsUser: 1000
        runAsGroup: 3000
        runAsNonRoot: true
        capabilities:
          drop:
            - ALL
          add:
            - NET_BIND_SERVICE
        privileged: false
        seccompProfile:
          type: RuntimeDefault
        seLinuxOptions:
          level: "s0:c123,c456"
        procMount: Default
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
        runAsNonRoot: true
      
      # Resource management with QoS
      resources:
        limits:
          memory: "{{ .Values.resources.limits.memory }}"
          cpu: "{{ .Values.resources.limits.cpu }}"
          ephemeral-storage: "1Gi"
        requests:
          memory: "{{ .Values.resources.requests.memory }}"
          cpu: "{{ .Values.resources.requests.cpu }}"
          ephemeral-storage: "100Mi"
      
      # Health checks
      livenessProbe:
        httpGet:
          path: /health
          port: 8080
          httpHeaders:
          - name: X-Custom-Header
            value: "health-check"
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 5
        failureThreshold: 3
        successThreshold: 1
      
      readinessProbe:
        httpGet:
          path: /ready
          port: 8080
        initialDelaySeconds: 5
        periodSeconds: 5
        timeoutSeconds: 3
        failureThreshold: 3
        successThreshold: 1
      
      startupProbe:
        httpGet:
          path: /startup
          port: 8080
        initialDelaySeconds: 10
        periodSeconds: 10
        timeoutSeconds: 5
        failureThreshold: 30
        successThreshold: 1
      
      # Lifecycle hooks
      lifecycle:
        preStop:
          exec:
            command: ["/bin/sh", "-c", "sleep 10"]
        postStart:
          exec:
            command: ["/bin/sh", "-c", "echo 'Container started' > /tmp/startup.log"]
      
      # Volume mounts with security
      volumeMounts:
        - name: config-volume
          mountPath: /app/config
          readOnly: true
          subPath: "{{ .Values.config.subPath }}"
        - name: tmp-volume
          mountPath: /tmp
          subPath: "{{ .Values.tmp.subPath }}"
        - name: logs-volume
          mountPath: /app/logs
          subPath: "{{ .Values.logs.subPath }}"
        - name: certs-volume
          mountPath: /app/certs
          readOnly: true
          subPath: "{{ .Values.certs.subPath }}"
      
      # Environment variables
      env:
        - name: NODE_ENV
          value: "production"
        - name: LOG_LEVEL
          value: "info"
        - name: METRICS_PORT
          value: "8080"
        - name: CONFIG_PATH
          value: "/app/config"
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
      
      # Port configuration
      ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        - name: metrics
          containerPort: 9090
          protocol: TCP
        - name: health
          containerPort: 8081
          protocol: TCP
  
  # Volume definitions
  volumes:
    - name: config-volume
      configMap:
        name: "{{ .Values.config.name }}"
        defaultMode: 0644
        items:
          - key: "{{ .Values.config.key }}"
            path: "{{ .Values.config.path }}"
    
    - name: tmp-volume
      emptyDir:
        medium: Memory
        sizeLimit: "100Mi"
    
    - name: logs-volume
      emptyDir:
        medium: Memory
        sizeLimit: "500Mi"
    
    - name: certs-volume
      secret:
        secretName: "{{ .Values.certs.secretName }}"
        defaultMode: 0400
        items:
          - key: "{{ .Values.certs.certKey }}"
            path: "{{ .Values.certs.certPath }}"
          - key: "{{ .Values.certs.keyKey }}"
            path: "{{ .Values.certs.keyPath }}"
  
  # Pod-level configurations
  restartPolicy: Always
  terminationGracePeriodSeconds: 30
  dnsPolicy: ClusterFirst
  hostNetwork: false
  hostPID: false
  hostIPC: false
  shareProcessNamespace: false
  automountServiceAccountToken: false
  
  # Service account
  serviceAccountName: "{{ .Values.serviceAccount.name }}"
  
  # Security context for the pod
  securityContext:
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000
    seccompProfile:
      type: RuntimeDefault
    sysctls:
      - name: net.ipv4.ip_local_port_range
        value: "32768 65535"
      - name: net.ipv4.tcp_max_syn_backlog
        value: "4096"
    fsGroupChangePolicy: OnRootMismatch
    supplementalGroups: [2000, 3000]
    seLinuxOptions:
      level: "s0:c123,c456"
